Muito do javascript foi importado para o node, exceto funções de manipulação do DOM, ou elementos do HTML, CSS.

Core Modules e Modulos de 3º(após serem instalados via npm install) podem sem importados para dentro do arquivo .js usando import ou require(atualmente mais utilizado) e salvando dentro de uma variavel, para que assim os metodos dentro deste modulo possa ser utilizado. Neste caso estamos importando o fs(file system) e usando o metodo readFile.

module.export - exporta um codigo que criamos, tornado-o assim um modulo interno
require - importa um modulo para o arquivo.
export default - outro metodo para exportar um bloco de codigo, necessario configurar no json ou usar a extensão .mjs
import - importa um modulo para o arquivo, necessario configurar no json ou usar a extensão .mjs

core modules - são modulos ja existentes dentro do node

é possivel passar argumentos via linha de comando, colocando estes argumentos depois do comando a ser executado, por exemplo node index.js, esse argumento ficam armazenados em forma de array dentro de um arquivo chamado process.argv

modulos externo podem ser utilizado após a instalação via npm install <nome> e para iniciar o npm em um projeto npm init

chalk - um modulo que melhora a visualização do console, por exemplo estilizar a fonte do que sera apresentado npm install chalk@4.1.2

readline - core module que possibilita capturar os dados vindos do user

inquirer - modulo externo que melhora a abstração dos dados e funciona com promises npm install --save inquirer@^8.0.0

event loop - mantem o node.js executando linha por linha de cima pra baixo.

event emitter -  se comporta como o event listener no navegador, é um core module chamado events, precisa que seja instanciado uma classe eventEmitter.

sync - codigo aguarda que linha finalize execução

async - codigo continua executando as linhas durante a execução de uma linha async, e assim que ela finaliza o codigo apresenta o resultado

throw - finaliza o programa e gera um erro

try catch - evidencia o erro da forma que desejamos

Core Modules fundamentais
  http - modulo para criar servidores http (responde uma requisição com dados html), é por ex a base do express, metodos utilizados, createServer(cria um servidor), liste(determina a porta)
    statusCode - informa o codigo da requisição, ex: 400 falha de servidor
    setHeader - altera o conteudo que será retornado

  path - trabalha o caminho dos arquivos
    resolve - posibilita achar o caminho até o arquivo desejado
    join - forma um path dinamico, com variaveis e valores fixos

  fs - leitura e escrita de arquivos
    readFile - le um arquivo existente
    writeFile -  escreve
    appendFile - atualiza o arquivo
    unlink - remove arquivos
    rename - renomeia arquivo
    stat - informa detalhes do arquivo, tamanho, data de criação, se é um arquivo ou diretorio
    existis - valida se diretorio existente
    mkdir - cria diretorios

  url - trabalha com endereços urls
    parse - resgata partes da url host, path, search query

  os - extrai infos do S.O.

Rotas são as paginas

iniciar um projeto rapidamente - npm init -y

npmjs.com - site onde todos os modulos podem ser encontrado.

para instalar packages somente para o projeto em desenvolvimento, para isso usamos a flag --save-dev, exemplo seria o nodemon

npm update - atualiza os packages
npx - executador de packages, ex instalação do react, ex na aula 6 npx cowsay "Texto que quiser"

npm run - cria uma rotina(script) de execução de comandos, essa configuração é feita no package.json na parte de script
  Ex: para automatizar a execução do comando node index.js, dentro do obj script do package json, inserimos o comando, exemplo na aula 5

package global - flag -g, nao fica salvo na pasta node_modulos e sim na maquina, assim podendo ser acessodo diretamente pelo terminal, em alguns caso é necessario usar o npm link para poder utilizar o pacote no projeto  

npm uninstall - desinstala packages

express - framework para nodejs - npm i express

Rotas são as urls que acessamos, exemplo www.exemplo.com/rota1, www.exemplo.com/rota2

setup express 
  importar - require e usar
  definir porta - 3000, 5500
  criar rota - url que será acessada(get, post, delete, put, verbos do http)
  metodo listen
  sendfile - envia um arquivo como resposta
  path é usado para acessar o diretorio e o arquivo

nodemon - resolve o problema de ficar reiniciado a app, fazendo com que cada vez que uma alteração for feita no codigo o server seja reiniciado auto, necessario instalar como dev dependencias npm i --save-dev nodemon

middlewares - codigos que ficam entre uma ação e outra, ex: validar se o user está logado, usasse o metodo use e o next()

req.param.<nome> - acessamos paramentros pelo url enviada pelo user, ex /user/:id 

envio de dados por post, são normalmente dados enviados de um form para uma url   
  necessita de middlewares (ex express.json) para ler os dados do body
  uma rota de metodo post


MONOLITO - CODIGO BACK E FRONT JUNTOS

route module - uma pasta onde todas as rotas serão alocadas e assim importadas para o arquivo principal

inserir css é necessario usar um middlewares chamado express.static e salvar os arquivos de estilização dentro de um novo dir chamado public

template engine - ferramenta que distribui a logica do produto para outros lugares deixando mais dinamica a pagina para o usuario(link diferentes e etc), utiliza o metodo mvc, engine que usaremos handlebars
  torna layouts reutilizaveis

handlebars - é uma template engine express-handlebars
  dados dinamicos colocados no html entre {{}}, é possivel inserir condicionais e loops(if, else e each(parecido com o forEach))
  Houve uma pequena alteração no Handlebars, que vai quebrar o código das aulas seguintes

  Para reparar basta trocar esta linha de código:
  app.engine('handlebars', exphbs())
  Por esta:
  app.engine('handlebars', exphbs.engine())
  Basicamente, precisamos invocar este método engine, que antes era opicional para realizar algumas configurações extras, agora ele é obrigatório para o funcionamento do pacote

  1 - instala express e handlebars
  2 - importa os pacotes e adiciona ao express a engine handlebars
  3 - criamos uma view no diretorio views com a ext handlebars ex home.handlebars
  4 - metodo render para enviar a view para req

  ex setup 
  const express = require('express')
  const exphbs = require('express-handlebars')
  const path = require('path')

  const app = express()

  app.engine('handlebars', exphbs.engine())
  app.set('view engine', 'handlebars')

  app.get('/', (req, res) => {
    res.render('home', {layout:false})//após ter um layout este atributo será removido
  })

Layout para template engine
  1-pasta layout dentro de views
  2-dentro do template colocamos uma tag{{{body}}} -> aqui sera inserido o corpo do site dinamicamente ex na aula 2 create layout

passar dado para a view
  1- atraves do metodo render que fica na rota da home no app.js
  2- um obj com key e value
  3- sintax {{dado}}

condicionais
  1-pode usar informa
  2-sintax {{#if algumacoisa}} oque sera impresso caso seja true {{/if}}
  3-sintax com else {{#if algumacoisa}} oque sera impresso caso cumpra um possibilidade {{else}} impresso a outra possibilidade {{/if}}

estrutura de repetição
  1-sintax {{#each}} ... {{/each}}
  2-chamamos os itens no array com {{this}} 
  3-enviar somente o necessário pra o front

with permitir abstrair as propriedades do obj sem precisar referencia o obj, ex ao inves de acessar a propriedade {{user.name}}, seria necessário só {{name}}
  1-sintax {{#with obj}} ... {{/with}}

partials - são como mini templates que precisam ser repetidos em diversos locais da aplicação, necessario modificações na implementação, parecido com componentes em react
  1- ficam no diretorio views/partials
  2- sintax {{> partial}}

css com handlebars é parecido com o express, basta linkar com os layouts

BANCO DE DADOS

Banco relacional - banco de dado(guarda os dados), tabelas(onde categorizamos os dados e inserimos), colunas(onde separamos os dados de uma tabela), dados, relacionamento(ligações entre as tabelas)

MySQL - gerenciador de banco de dados.

utilizaremos o xampp

comandos terminal
  1 - ir em variaveis de ambientes
  2 - editar path inserindo o caminho das pasta c:\xampp\mysql\bin\
  3 - abnrir xampp e dar start no mysql - sempre que for usar
  4 - mysql -u root - sempre que for usar
  5 - workbench instalar (ferramenta de visualização)

integrando node e MySQL
  1- package mysql npm
  2 - configura o padrão do express
  3 - cria a config de conexão, no caso usaremos este padrão 
    const conn = mysql.createConnection({
      host: 'localhost', 
      user: 'root',
      password: '',
      database: 'nodemysql'
    })
  4 - estabelecendo a conexão
    conn.connect(function (err) {
      if(err){
          console.log (err)
      }

      console.log('Conectado ao MySQL')

      app.listen(3000)
    })
  5 - criar o banco de dados no workbench
    1-clique no botão de criar banco de dados e dar o mesmo nome que demos no database
    2-npm start

criando tabela, no caso onde iremos inserir os dados a serem manipulados, no ex a tabela se chamara books e usaremos para cadastrar livro com as seguintes infos titulo e numero de paginas
  1-clica em new table e insere o nome e as colunas que serão utilizadas (title, page e id)

inserir dados 
  1- criar e executar query(metodo do mysql)
  2- usaremos o insert para inserir dados exemplo aula 2

resgatando dados
  1- criar e executar uma nova query
  2 - metodo select agora que retorna os dados para inserirmos na views

resgatar dado especifico
  1 -metodo where, filtra pela coluna e valor

editar dados
  1 - resgatar o dado a ser editado
  2 - preenchemos o formulario dos dados, mostrando tudo que tem cadastrado daquele dados
  3 - mostro para o user escolher oque editar

enviar dados editados
  1 - rota post
  2 - query update
  3 - passar o id do livro para localizar corretamente o dado

remover dados
  1 - rota post com id
  2 - query delete

Utilizando driver connection pool
  Cria um cache de dados, tornando muito mais agi
  Criasse uma pasta db e o arquivo conn.js, import o drive mysql
  cria o pool utilizando os dados da createConnection e inserindo o coonectionLimit

preparando as queries, para evitar sql injection
utilizasse ? ao inves de valores
um segundo passo é executado para mandar os dados corretamente
obrigatorio utilizar em aplicações reais

SEQUELIZE
ORM (Object relation mapper), abstrai a complexidade das queries
normalmente é menos performatica que realizar os comando puros de sql
baseado em promises(then e catch)
Necessário criar um model(reflexo do que sera nossa tabela em forma de classe)
necessário instalar via npm
a config da conexão segue praticamente o mesmo padrão do outro pacote(mysql) - banco, usuario e senha, por isso vamos reutilizar parte do que ja existe do mod anterior, ver mod 9-1-bd-conn
necessario instaciar a class sequelizwe
é possivel checar conexão com o metodo authenticate
